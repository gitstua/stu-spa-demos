<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jigsaw Puzzle Maker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .upload-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            padding: 15px 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .sample-images {
            margin: 20px 0;
            text-align: center;
        }

        .sample-images h3 {
            color: #555;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .sample-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .sample-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .sample-btn:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .sample-btn img {
            width: 80px;
            height: 60px;
            object-fit: cover;
            border-radius: 5px;
            margin-bottom: 8px;
        }

        .sample-btn span {
            font-size: 0.9em;
            font-weight: bold;
            color: #555;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: bold;
            color: #555;
        }

        input[type="range"] {
            width: 150px;
        }

        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #45a049;
            transform: translateY(-1px);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        #cheatBtn {
            background: #ff6b6b;
        }

        #cheatBtn:hover {
            background: #ff5252;
        }

        #cheatBtn:disabled {
            background: #ccc;
        }

        .cheating-piece {
            border: 4px solid #ff6b6b !important;
            animation: cheatPulse 0.8s ease-in-out infinite alternate;
            z-index: 1000 !important;
            transform: scale(1.05) !important;
        }

        @keyframes cheatPulse {
            0% { 
                border-color: #ff6b6b;
                box-shadow: 0 0 15px rgba(255, 107, 107, 0.7), 0 0 30px rgba(255, 107, 107, 0.3);
                transform: scale(1.05) rotate(1deg);
            }
            50% {
                border-color: #ff5252;
                box-shadow: 0 0 25px rgba(255, 107, 107, 0.9), 0 0 50px rgba(255, 107, 107, 0.5);
                transform: scale(1.08) rotate(-1deg);
            }
            100% { 
                border-color: #ff1744;
                box-shadow: 0 0 35px rgba(255, 107, 107, 1), 0 0 70px rgba(255, 107, 107, 0.7);
                transform: scale(1.05) rotate(1deg);
            }
        }

        .piece-moving {
            transition: none;
            cursor: grabbing !important;
        }

        .piece-dragging-animation {
            animation: dragToPosition 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        @keyframes dragToPosition {
            0% {
                transform: scale(1);
            }
            20% {
                transform: scale(1.1) rotate(2deg);
            }
            40% {
                transform: scale(1.05) rotate(-1deg);
            }
            60% {
                transform: scale(1.08) rotate(1deg);
            }
            80% {
                transform: scale(1.02) rotate(-0.5deg);
            }
            100% {
                transform: scale(1) rotate(0deg);
            }
        }

        .puzzle-container {
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .puzzle-area {
            position: relative;
            border: 3px dashed #ddd;
            border-radius: 15px;
            min-height: 400px;
            min-width: 400px;
            background: #f9f9f9;
            overflow: hidden;
        }

        .puzzle-piece {
            position: absolute;
            cursor: grab;
            user-select: none;
            transition: transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .puzzle-piece:hover {
            transform: scale(1.05);
            z-index: 10;
        }

        .puzzle-piece.dragging {
            cursor: grabbing;
            z-index: 100;
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .puzzle-piece.placed {
            border: 3px solid #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
            animation: placedPulse 1.5s ease-in-out infinite;
        }

        @keyframes placedPulse {
            0% {
                border-color: #4CAF50;
                box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
            }
            50% {
                border-color: #45a049;
                box-shadow: 0 0 25px rgba(76, 175, 80, 0.8);
            }
            100% {
                border-color: #4CAF50;
                box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
            }
        }

        .original-image {
            max-width: 300px;
            max-height: 300px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .completion-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 30px;
            border-radius: 20px;
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
            animation: celebration 0.5s ease-out;
        }

        .fullscreen-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #f9f9f9;
            z-index: 9999;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .fullscreen-puzzle-area {
            width: 400px;
            height: 400px;
            border: 3px dashed #ddd;
            border-radius: 15px;
            background: #f9f9f9;
            overflow: hidden;
            position: relative;
        }

        .fullscreen-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        .exit-fullscreen-btn {
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
        }

        .exit-fullscreen-btn:hover {
            background: rgba(0,0,0,0.9);
        }

        #fullscreenCheatBtn {
            background: #ff6b6b !important;
        }

        #fullscreenCheatBtn:hover {
            background: #ff5252 !important;
        }

        .fullscreen-stats {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1.2em;
            font-weight: bold;
            z-index: 100;
        }

        #fullscreenCompletionMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 30px;
            border-radius: 20px;
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            z-index: 10000;
            display: none;
            animation: celebration 0.5s ease-out;
        }

        @keyframes celebration {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .piece-just-placed {
            animation: piecePlacementCelebration 0.8s ease-out;
        }

        @keyframes piecePlacementCelebration {
            0% {
                transform: scale(1);
                border-color: #4CAF50;
                box-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
            }
            25% {
                transform: scale(1.15) rotate(2deg);
                border-color: #45a049;
                box-shadow: 0 0 40px rgba(76, 175, 80, 1);
            }
            50% {
                transform: scale(1.1) rotate(-1deg);
                border-color: #4CAF50;
                box-shadow: 0 0 30px rgba(76, 175, 80, 0.9);
            }
            75% {
                transform: scale(1.05) rotate(0.5deg);
                border-color: #45a049;
                box-shadow: 0 0 25px rgba(76, 175, 80, 0.8);
            }
            100% {
                transform: scale(1);
                border-color: #4CAF50;
                box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
            }
        }

        .stats {
            text-align: center;
            margin-top: 20px;
            font-size: 1.2em;
            color: #666;
        }

        @media (max-width: 768px) {
            .puzzle-container {
                flex-direction: column;
                align-items: center;
            }
            
            .puzzle-area {
                min-width: 300px;
                min-height: 300px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .sample-buttons {
                gap: 10px;
            }
            
            .sample-btn {
                min-width: 80px;
                padding: 8px;
            }
            
            .sample-btn img {
                width: 60px;
                height: 45px;
            }
            
            .sample-btn span {
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🧩 Jigsaw Puzzle Maker</h1>
        
        <div class="upload-section">
            <div class="file-input-wrapper">
                <input type="file" id="imageInput" class="file-input" accept="image/*">
                <label for="imageInput" class="file-input-label">Choose Image</label>
            </div>
            
            <div class="sample-images">
                <h3>Or try these sample images:</h3>
                <div class="sample-buttons">
                    <button class="sample-btn" data-url="https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600&fit=crop">
                        <img src="https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=150&h=100&fit=crop" alt="Mountain Landscape">
                        <span>Mountain</span>
                    </button>
                    <button class="sample-btn" data-url="https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=800&h=600&fit=crop">
                        <img src="https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=150&h=100&fit=crop" alt="Forest">
                        <span>Forest</span>
                    </button>
                    <button class="sample-btn" data-url="https://images.unsplash.com/photo-1507525428034-b723cf961d3e?w=800&h=600&fit=crop">
                        <img src="https://images.unsplash.com/photo-1507525428034-b723cf961d3e?w=150&h=100&fit=crop" alt="Ocean">
                        <span>Ocean</span>
                    </button>
                    <button class="sample-btn" data-url="https://images.unsplash.com/photo-1501594907352-04cda38ebc29?w=800&h=600&fit=crop">
                        <img src="https://images.unsplash.com/photo-1501594907352-04cda38ebc29?w=150&h=100&fit=crop" alt="City Skyline">
                        <span>City</span>
                    </button>
                    <button class="sample-btn" data-url="https://images.unsplash.com/photo-1490750967868-88aa4486c946?w=800&h=600&fit=crop">
                        <img src="https://images.unsplash.com/photo-1490750967868-88aa4486c946?w=150&h=100&fit=crop" alt="Flowers">
                        <span>Flowers</span>
                    </button>
                    <button class="sample-btn" data-url="https://images.unsplash.com/photo-1565178117145-41db4d572950?w=800&h=600&fit=crop">
                        <img src="https://images.unsplash.com/photo-1565178117145-41db4d572950?w=150&h=100&fit=crop" alt="Bamboo Forest">
                        <span>Bamboo</span>
                    </button>
                    <button class="sample-btn" data-url="https://images.unsplash.com/photo-1493976040374-85c8e12f0c0e?w=800&h=600&fit=crop">
                        <img src="https://images.unsplash.com/photo-1493976040374-85c8e12f0c0e?w=150&h=100&fit=crop" alt="Kyoto Temple">
                        <span>Kyoto</span>
                    </button>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label for="rows">Rows:</label>
                    <input type="range" id="rows" min="2" max="30" value="4">
                    <span id="rowsValue">4</span>
                </div>
                <div class="control-group">
                    <label for="cols">Columns:</label>
                    <input type="range" id="cols" min="2" max="30" value="4">
                    <span id="colsValue">4</span>
                </div>
                <button id="generateBtn" disabled>Generate Puzzle</button>
                <button id="fullscreenBtn" disabled>Fullscreen</button>
                <button id="cheatBtn" disabled>😬</button>
                <button id="resetBtn" disabled>Reset</button>
            </div>
        </div>

        <div class="puzzle-container">
            <div class="puzzle-area" id="puzzleArea">
                <p style="text-align: center; margin-top: 180px; color: #999;">
                    Upload an image and click "Generate Puzzle" to start!
                </p>
            </div>
            <div id="originalImageContainer" style="display: none;">
                <img id="originalImage" class="original-image" alt="Original image">
            </div>
        </div>

        <div class="stats" id="stats">
            <p>Pieces placed: <span id="placedCount">0</span> / <span id="totalCount">0</span></p>
        </div>
    </div>

    <div class="completion-message" id="completionMessage">
        🎉 Congratulations! You completed the puzzle! 🎉
    </div>

    <div class="fullscreen-mode" id="fullscreenMode">
        <div class="fullscreen-controls">
            <button class="exit-fullscreen-btn" id="exitFullscreenBtn">Exit Fullscreen</button>
            <button class="exit-fullscreen-btn" id="fullscreenCheatBtn" style="margin-left: 10px;">😬</button>
        </div>
        <div class="fullscreen-puzzle-area" id="fullscreenPuzzleArea">
        </div>
        <div class="fullscreen-stats" id="fullscreenStats">
            <p>Pieces placed: <span id="fullscreenPlacedCount">0</span> / <span id="fullscreenTotalCount">0</span></p>
        </div>
    </div>

    <div class="completion-message" id="fullscreenCompletionMessage">
        🎉 Congratulations! You completed the puzzle! 🎉
    </div>

    <script>
        class JigsawPuzzle {
            constructor() {
                this.image = null;
                this.pieces = [];
                this.rows = 4;
                this.cols = 4;
                this.pieceWidth = 0;
                this.pieceHeight = 0;
                this.placedPieces = 0;
                this.totalPieces = 0;
                
                this.initializeElements();
                this.setupEventListeners();
            }

            initializeElements() {
                this.imageInput = document.getElementById('imageInput');
                this.rowsSlider = document.getElementById('rows');
                this.colsSlider = document.getElementById('cols');
                this.rowsValue = document.getElementById('rowsValue');
                this.colsValue = document.getElementById('colsValue');
                this.generateBtn = document.getElementById('generateBtn');
                this.fullscreenBtn = document.getElementById('fullscreenBtn');
                this.cheatBtn = document.getElementById('cheatBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.puzzleArea = document.getElementById('puzzleArea');
                this.originalImageContainer = document.getElementById('originalImageContainer');
                this.originalImage = document.getElementById('originalImage');
                this.stats = document.getElementById('stats');
                this.placedCount = document.getElementById('placedCount');
                this.totalCount = document.getElementById('totalCount');
                this.completionMessage = document.getElementById('completionMessage');
                this.fullscreenMode = document.getElementById('fullscreenMode');
                this.fullscreenPuzzleArea = document.getElementById('fullscreenPuzzleArea');
                this.exitFullscreenBtn = document.getElementById('exitFullscreenBtn');
                this.fullscreenCheatBtn = document.getElementById('fullscreenCheatBtn');
                this.fullscreenStats = document.getElementById('fullscreenStats');
                this.fullscreenPlacedCount = document.getElementById('fullscreenPlacedCount');
                this.fullscreenTotalCount = document.getElementById('fullscreenTotalCount');
                this.fullscreenCompletionMessage = document.getElementById('fullscreenCompletionMessage');
            }

            setupEventListeners() {
                this.imageInput.addEventListener('change', (e) => this.handleImageUpload(e));
                this.rowsSlider.addEventListener('input', (e) => this.updateSliderValue(e, this.rowsValue));
                this.colsSlider.addEventListener('input', (e) => this.updateSliderValue(e, this.colsValue));
                this.generateBtn.addEventListener('click', () => this.generatePuzzle());
                this.fullscreenBtn.addEventListener('click', () => this.enterFullscreen());
                this.cheatBtn.addEventListener('mousedown', () => this.startCheat());
                this.cheatBtn.addEventListener('mouseup', () => this.stopCheat());
                this.cheatBtn.addEventListener('mouseleave', () => this.stopCheat());
                this.cheatBtn.addEventListener('touchstart', () => this.startCheat());
                this.cheatBtn.addEventListener('touchend', () => this.stopCheat());
                this.fullscreenCheatBtn.addEventListener('mousedown', () => this.startCheat());
                this.fullscreenCheatBtn.addEventListener('mouseup', () => this.stopCheat());
                this.fullscreenCheatBtn.addEventListener('mouseleave', () => this.stopCheat());
                this.fullscreenCheatBtn.addEventListener('touchstart', () => this.startCheat());
                this.fullscreenCheatBtn.addEventListener('touchend', () => this.stopCheat());
                this.resetBtn.addEventListener('click', () => this.resetPuzzle());
                this.exitFullscreenBtn.addEventListener('click', () => this.exitFullscreen());
                
                // Add event listeners for sample image buttons
                document.querySelectorAll('.sample-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.loadSampleImage(e.target.closest('.sample-btn').dataset.url));
                });
            }

            updateSliderValue(e, valueElement) {
                valueElement.textContent = e.target.value;
            }

            loadSampleImage(imageUrl) {
                // Show loading state
                this.generateBtn.disabled = true;
                this.generateBtn.textContent = 'Loading...';
                
                this.image = new Image();
                this.image.crossOrigin = 'anonymous'; // Enable CORS for external images
                
                this.image.onload = () => {
                    this.originalImage.src = imageUrl;
                    this.originalImageContainer.style.display = 'block';
                    this.generateBtn.disabled = false;
                    this.generateBtn.textContent = 'Generate Puzzle';
                };
                
                this.image.onerror = () => {
                    alert('Failed to load the sample image. Please try another one.');
                    this.generateBtn.disabled = false;
                    this.generateBtn.textContent = 'Generate Puzzle';
                };
                
                this.image.src = imageUrl;
            }

            handleImageUpload(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        this.image = new Image();
                        this.image.onload = () => {
                            this.originalImage.src = event.target.result;
                            this.originalImageContainer.style.display = 'block';
                            this.generateBtn.disabled = false;
                        };
                        this.image.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            }

            generatePuzzle() {
                if (!this.image) return;

                this.rows = parseInt(this.rowsSlider.value);
                this.cols = parseInt(this.colsSlider.value);
                this.totalPieces = this.rows * this.cols;
                this.placedPieces = 0;

                // Clear previous puzzle
                this.puzzleArea.innerHTML = '';
                this.pieces = [];

                // Calculate piece dimensions with small gaps
                const gap = 2;
                const areaWidth = this.puzzleArea.offsetWidth - 20;
                const areaHeight = this.puzzleArea.offsetHeight - 20;
                this.pieceWidth = (areaWidth - gap * (this.cols - 1)) / this.cols;
                this.pieceHeight = (areaHeight - gap * (this.rows - 1)) / this.rows;

                // Create puzzle pieces
                this.createPuzzlePieces();

                // Shuffle pieces
                this.shufflePieces();

                // Update UI
                this.updateStats();
                this.resetBtn.disabled = false;
                this.fullscreenBtn.disabled = false;
                this.cheatBtn.disabled = false;
            }

            createPuzzlePieces() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = this.image.width;
                canvas.height = this.image.height;
                ctx.drawImage(this.image, 0, 0);

                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const piece = this.createPuzzlePiece(canvas, row, col);
                        this.pieces.push(piece);
                    }
                }
            }

            createPuzzlePiece(sourceCanvas, row, col) {
                const pieceCanvas = document.createElement('canvas');
                const ctx = pieceCanvas.getContext('2d');
                
                const sourceX = (col * sourceCanvas.width) / this.cols;
                const sourceY = (row * sourceCanvas.height) / this.rows;
                const sourceWidth = sourceCanvas.width / this.cols;
                const sourceHeight = sourceCanvas.height / this.rows;

                // Make canvas larger to accommodate jigsaw tabs
                const tabSize = Math.min(sourceWidth, sourceHeight) * 0.15;
                const padding = tabSize * 2;
                pieceCanvas.width = sourceWidth + padding;
                pieceCanvas.height = sourceHeight + padding;

                // Draw the image portion first
                ctx.drawImage(
                    sourceCanvas,
                    sourceX, sourceY, sourceWidth, sourceHeight,
                    padding/2, padding/2, sourceWidth, sourceHeight
                );

                // Create jigsaw shape mask
                ctx.globalCompositeOperation = 'destination-in';
                ctx.beginPath();
                this.drawJigsawPieceShape(ctx, padding/2, padding/2, sourceWidth, sourceHeight, row, col);
                ctx.fill();

                // Create piece element
                const pieceElement = document.createElement('div');
                pieceElement.className = 'puzzle-piece';
                pieceElement.style.width = this.pieceWidth + 'px';
                pieceElement.style.height = this.pieceHeight + 'px';
                pieceElement.style.backgroundImage = `url(${pieceCanvas.toDataURL()})`;
                pieceElement.style.backgroundSize = 'cover';
                pieceElement.style.backgroundPosition = 'center';

                // Store piece data
                const gap = 2;
                pieceElement.pieceData = {
                    row,
                    col,
                    correctX: col * (this.pieceWidth + gap),
                    correctY: row * (this.pieceHeight + gap),
                    isPlaced: false
                };

                this.puzzleArea.appendChild(pieceElement);
                return pieceElement;
            }

            drawJigsawPieceShape(ctx, x, y, width, height, row, col) {
                const tabSize = Math.min(width, height) * 0.2;
                
                ctx.beginPath();
                
                // Start from top-left corner
                ctx.moveTo(x, y + height * 0.1);
                
                // Top side
                if (row > 0) {
                    // Has piece above - create tab
                    ctx.lineTo(x + width * 0.3, y);
                    this.drawJigsawTab(ctx, x + width * 0.5, y, tabSize, 'out');
                    ctx.lineTo(x + width * 0.7, y);
                    ctx.lineTo(x + width, y + height * 0.1);
                } else {
                    // Edge piece - straight line
                    ctx.lineTo(x + width, y + height * 0.1);
                }
                
                // Right side
                if (col < this.cols - 1) {
                    // Has piece to the right - create tab
                    ctx.lineTo(x + width, y + height * 0.3);
                    this.drawJigsawTab(ctx, x + width, y + height * 0.5, tabSize, 'out');
                    ctx.lineTo(x + width, y + height * 0.7);
                    ctx.lineTo(x + width * 0.9, y + height);
                } else {
                    // Edge piece - straight line
                    ctx.lineTo(x + width * 0.9, y + height);
                }
                
                // Bottom side
                if (row < this.rows - 1) {
                    // Has piece below - create tab
                    ctx.lineTo(x + width * 0.7, y + height);
                    this.drawJigsawTab(ctx, x + width * 0.5, y + height, tabSize, 'in');
                    ctx.lineTo(x + width * 0.3, y + height);
                    ctx.lineTo(x, y + height * 0.9);
                } else {
                    // Edge piece - straight line
                    ctx.lineTo(x, y + height * 0.9);
                }
                
                // Left side
                if (col > 0) {
                    // Has piece to the left - create tab
                    ctx.lineTo(x, y + height * 0.7);
                    this.drawJigsawTab(ctx, x, y + height * 0.5, tabSize, 'in');
                    ctx.lineTo(x, y + height * 0.3);
                    ctx.lineTo(x + width * 0.1, y);
                } else {
                    // Edge piece - straight line
                    ctx.lineTo(x + width * 0.1, y);
                }
                
                ctx.closePath();
            }

            drawJigsawTab(ctx, x, y, size, type) {
                const offset = type === 'out' ? size : -size;
                const halfSize = size * 0.5;
                
                // Create a proper jigsaw tab shape
                ctx.quadraticCurveTo(
                    x + halfSize,
                    y + offset * 0.2,
                    x + offset,
                    y + offset * 0.4
                );
                ctx.quadraticCurveTo(
                    x + offset,
                    y + offset * 0.6,
                    x + halfSize,
                    y + offset
                );
                ctx.quadraticCurveTo(
                    x,
                    y + offset * 0.8,
                    x,
                    y + size
                );
            }

            shufflePieces() {
                this.pieces.forEach((piece, index) => {
                    const randomX = Math.random() * (this.puzzleArea.offsetWidth - this.pieceWidth);
                    const randomY = Math.random() * (this.puzzleArea.offsetHeight - this.pieceHeight);
                    
                    piece.style.left = randomX + 'px';
                    piece.style.top = randomY + 'px';
                    
                    this.setupPieceDragAndDrop(piece);
                });
            }

            setupPieceDragAndDrop(piece) {
                let isDragging = false;
                let startX, startY, initialX, initialY;

                // Mouse events
                piece.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', endDrag);

                // Touch events
                piece.addEventListener('touchstart', startDrag, { passive: false });
                document.addEventListener('touchmove', drag, { passive: false });
                document.addEventListener('touchend', endDrag);

                function startDrag(e) {
                    isDragging = true;
                    piece.classList.add('dragging');
                    
                    const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                    
                    startX = clientX;
                    startY = clientY;
                    
                    const rect = piece.getBoundingClientRect();
                    const puzzleRect = piece.parentElement.getBoundingClientRect();
                    
                    initialX = rect.left - puzzleRect.left;
                    initialY = rect.top - puzzleRect.top;
                    
                    e.preventDefault();
                }

                function drag(e) {
                    if (!isDragging) return;
                    
                    const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                    
                    const deltaX = clientX - startX;
                    const deltaY = clientY - startY;
                    
                    piece.style.left = (initialX + deltaX) + 'px';
                    piece.style.top = (initialY + deltaY) + 'px';
                    
                    e.preventDefault();
                }

                function endDrag(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    piece.classList.remove('dragging');
                    
                    // Check if piece is in correct position
                    const rect = piece.getBoundingClientRect();
                    const puzzleRect = piece.parentElement.getBoundingClientRect();
                    
                    const currentX = rect.left - puzzleRect.left;
                    const currentY = rect.top - puzzleRect.top;
                    
                    const tolerance = 30; // pixels
                    const isCorrectX = Math.abs(currentX - piece.pieceData.correctX) < tolerance;
                    const isCorrectY = Math.abs(currentY - piece.pieceData.correctY) < tolerance;
                    
                    if (isCorrectX && isCorrectY && !piece.pieceData.isPlaced) {
                        // Snap to correct position
                        piece.style.left = piece.pieceData.correctX + 'px';
                        piece.style.top = piece.pieceData.correctY + 'px';
                        piece.classList.add('placed', 'piece-just-placed');
                        piece.pieceData.isPlaced = true;
                        
                        // Remove celebration animation after it completes
                        setTimeout(() => {
                            piece.classList.remove('piece-just-placed');
                        }, 800);
                        
                        // Check if we're in fullscreen mode
                        const isFullscreen = piece.parentElement.id === 'fullscreenPuzzleArea';
                        const puzzleInstance = isFullscreen ? 
                            document.querySelector('#fullscreenMode').puzzleInstance : puzzle;
                        
                        if (isFullscreen) {
                            puzzleInstance.updateFullscreenStats();
                            puzzleInstance.checkFullscreenCompletion();
                        } else {
                            puzzleInstance.updateStats();
                            puzzleInstance.checkCompletion();
                        }
                    }
                }
            }

            updateStats() {
                // Check if we're in fullscreen mode
                const isFullscreen = this.fullscreenMode.style.display === 'flex';
                const puzzleArea = isFullscreen ? this.fullscreenPuzzleArea : this.puzzleArea;
                const pieces = Array.from(puzzleArea.querySelectorAll('.puzzle-piece'));
                
                this.placedPieces = pieces.filter(piece => piece.pieceData.isPlaced).length;
                this.placedCount.textContent = this.placedPieces;
                this.totalCount.textContent = this.totalPieces;
            }

            updateFullscreenStats() {
                const pieces = Array.from(this.fullscreenPuzzleArea.querySelectorAll('.puzzle-piece'));
                const placedPieces = pieces.filter(piece => piece.pieceData.isPlaced).length;
                this.fullscreenPlacedCount.textContent = placedPieces;
                this.fullscreenTotalCount.textContent = this.totalPieces;
            }

            syncPositionsFromFullscreen() {
                if (!this.fullscreenMode.puzzleInstance) return;
                
                const fullscreenPieces = Array.from(this.fullscreenPuzzleArea.querySelectorAll('.puzzle-piece'));
                const scaleFactor = this.fullscreenMode.scaleFactor || 1;
                
                fullscreenPieces.forEach(fullscreenPiece => {
                    // Find corresponding regular piece by row/col
                    const pieceData = fullscreenPiece.pieceData;
                    const regularPiece = this.pieces.find(piece => 
                        piece.pieceData.row === pieceData.row && 
                        piece.pieceData.col === pieceData.col
                    );
                    
                    if (regularPiece) {
                        // Scale down position
                        const scaledLeft = parseFloat(fullscreenPiece.style.left) || 0;
                        const scaledTop = parseFloat(fullscreenPiece.style.top) || 0;
                        
                        regularPiece.style.left = (scaledLeft / scaleFactor) + 'px';
                        regularPiece.style.top = (scaledTop / scaleFactor) + 'px';
                        
                        // Sync placed state
                        if (fullscreenPiece.classList.contains('placed')) {
                            regularPiece.classList.add('placed');
                            regularPiece.pieceData.isPlaced = true;
                        } else {
                            regularPiece.classList.remove('placed');
                            regularPiece.pieceData.isPlaced = false;
                        }
                    }
                });
            }

            checkCompletion() {
                if (this.placedPieces === this.totalPieces) {
                    setTimeout(() => {
                        this.completionMessage.style.display = 'block';
                        setTimeout(() => {
                            this.completionMessage.style.display = 'none';
                        }, 3000);
                    }, 500);
                }
            }

            checkFullscreenCompletion() {
                const pieces = Array.from(this.fullscreenPuzzleArea.querySelectorAll('.puzzle-piece'));
                const placedPieces = pieces.filter(piece => piece.pieceData.isPlaced).length;
                
                if (placedPieces === this.totalPieces) {
                    setTimeout(() => {
                        this.fullscreenCompletionMessage.style.display = 'block';
                        setTimeout(() => {
                            this.fullscreenCompletionMessage.style.display = 'none';
                        }, 3000);
                    }, 500);
                }
            }

            enterFullscreen() {
                if (!this.pieces || this.pieces.length === 0) {
                    console.log('No pieces available for fullscreen mode');
                    return;
                }
                
                // Show fullscreen mode first to get proper dimensions
                this.fullscreenMode.style.display = 'flex';
                document.body.style.overflow = 'hidden';
                
                // Wait for layout to update, then calculate scale factor
                setTimeout(() => {
                    // Calculate scale factor to use more available space
                    const originalAreaSize = 400; // Original puzzle area size
                    const availableWidth = window.innerWidth * 0.9;
                    const availableHeight = window.innerHeight * 0.8;
                    const maxScale = Math.min(availableWidth, availableHeight) / originalAreaSize;
                    const scaleFactor = Math.max(1, maxScale);
                    
                    // Resize the fullscreen puzzle area to match the scaled puzzle
                    const scaledAreaSize = originalAreaSize * scaleFactor;
                    this.fullscreenPuzzleArea.style.width = scaledAreaSize + 'px';
                    this.fullscreenPuzzleArea.style.height = scaledAreaSize + 'px';
                    
                    // Copy pieces to fullscreen area with scaled dimensions and positions
                    this.fullscreenPuzzleArea.innerHTML = '';
                    
                    // Store reference to puzzle instance and scale factor for drag and drop
                    this.fullscreenMode.puzzleInstance = this;
                    this.fullscreenMode.scaleFactor = scaleFactor;
                    
                    this.pieces.forEach(piece => {
                        const clonedPiece = piece.cloneNode(true);
                        
                        // Scale up piece size
                        const originalWidth = parseFloat(piece.style.width) || this.pieceWidth;
                        const originalHeight = parseFloat(piece.style.height) || this.pieceHeight;
                        clonedPiece.style.width = (originalWidth * scaleFactor) + 'px';
                        clonedPiece.style.height = (originalHeight * scaleFactor) + 'px';
                        
                        // Scale up position
                        const originalLeft = parseFloat(piece.style.left) || 0;
                        const originalTop = parseFloat(piece.style.top) || 0;
                        clonedPiece.style.left = (originalLeft * scaleFactor) + 'px';
                        clonedPiece.style.top = (originalTop * scaleFactor) + 'px';
                        
                        // Update piece data with scaled correct positions
                        const pieceData = piece.pieceData;
                        const gap = 2;
                        clonedPiece.pieceData = {
                            ...pieceData,
                            correctX: pieceData.col * (this.pieceWidth * scaleFactor + gap * scaleFactor),
                            correctY: pieceData.row * (this.pieceHeight * scaleFactor + gap * scaleFactor)
                        };
                        
                        // Copy the placed state
                        if (piece.classList.contains('placed')) {
                            clonedPiece.classList.add('placed');
                        }
                        
                        this.fullscreenPuzzleArea.appendChild(clonedPiece);
                        this.setupPieceDragAndDrop(clonedPiece);
                    });
                    
                    // Update fullscreen stats
                    this.updateFullscreenStats();
                }, 100);
            }

            exitFullscreen() {
                // Sync positions back to regular puzzle
                this.syncPositionsFromFullscreen();
                
                this.fullscreenMode.style.display = 'none';
                document.body.style.overflow = 'auto';
                
                // Update regular stats
                this.updateStats();
            }

            startCheat() {
                // Determine which puzzle area we're working with
                const isFullscreen = this.fullscreenMode.style.display === 'flex';
                const puzzleArea = isFullscreen ? this.fullscreenPuzzleArea : this.puzzleArea;
                const pieces = Array.from(puzzleArea.querySelectorAll('.puzzle-piece'));
                
                if (pieces.length === 0) return;
                
                // Find all unplaced pieces
                const unplacedPieces = pieces.filter(piece => !piece.pieceData.isPlaced);
                if (unplacedPieces.length === 0) return;
                
                // Select a random unplaced piece
                const randomPiece = unplacedPieces[Math.floor(Math.random() * unplacedPieces.length)];
                this.animatePieceToCorrectPosition(randomPiece);
                
                // Start auto-solve if button is held down
                this.cheatInterval = setInterval(() => {
                    const remainingUnplacedPieces = pieces.filter(piece => !piece.pieceData.isPlaced);
                    if (remainingUnplacedPieces.length > 0) {
                        const randomPiece = remainingUnplacedPieces[Math.floor(Math.random() * remainingUnplacedPieces.length)];
                        this.animatePieceToCorrectPosition(randomPiece);
                    } else {
                        this.stopCheat();
                    }
                }, 600); // Slower interval to allow animation to complete
            }

            animatePieceToCorrectPosition(piece) {
                // Add cheating animation class
                piece.classList.add('cheating-piece');
                piece.classList.add('piece-moving');
                
                // Get current and target positions
                const currentLeft = parseFloat(piece.style.left) || 0;
                const currentTop = parseFloat(piece.style.top) || 0;
                const targetLeft = piece.pieceData.correctX;
                const targetTop = piece.pieceData.correctY;
                
                // Calculate distance for realistic movement
                const deltaX = targetLeft - currentLeft;
                const deltaY = targetTop - currentTop;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Create realistic dragging path with slight overshoot
                const steps = Math.max(20, Math.floor(distance / 10));
                const stepSize = 1 / steps;
                
                let currentStep = 0;
                const animateStep = () => {
                    if (currentStep >= 1) {
                        // Final position
                        piece.style.left = targetLeft + 'px';
                        piece.style.top = targetTop + 'px';
                        
                        // Add dragging animation effect
                        piece.classList.add('piece-dragging-animation');
                        
                        // Clean up after animation
                        setTimeout(() => {
                            piece.classList.remove('cheating-piece', 'piece-moving', 'piece-dragging-animation');
                            piece.classList.add('placed', 'piece-just-placed');
                            piece.pieceData.isPlaced = true;
                            
                            // Remove celebration animation after it completes
                            setTimeout(() => {
                                piece.classList.remove('piece-just-placed');
                            }, 800);
                            
                            // Check if we're in fullscreen mode and update accordingly
                            const isFullscreen = piece.parentElement.id === 'fullscreenPuzzleArea';
                            const puzzleInstance = isFullscreen ? 
                                document.querySelector('#fullscreenMode').puzzleInstance : this;
                            
                            if (isFullscreen) {
                                puzzleInstance.updateFullscreenStats();
                                puzzleInstance.checkFullscreenCompletion();
                            } else {
                                puzzleInstance.updateStats();
                                puzzleInstance.checkCompletion();
                            }
                        }, 1000);
                        return;
                    }
                    
                    // Easing function for natural movement
                    const easedStep = this.easeInOutCubic(currentStep);
                    
                    // Add slight overshoot and correction
                    let overshootFactor = 1;
                    if (currentStep > 0.7) {
                        overshootFactor = 1 + (0.1 * Math.sin((currentStep - 0.7) * Math.PI * 3.33));
                    }
                    
                    // Calculate intermediate position
                    const intermediateX = currentLeft + (deltaX * easedStep * overshootFactor);
                    const intermediateY = currentTop + (deltaY * easedStep * overshootFactor);
                    
                    // Apply position
                    piece.style.left = intermediateX + 'px';
                    piece.style.top = intermediateY + 'px';
                    
                    currentStep += stepSize;
                    requestAnimationFrame(animateStep);
                };
                
                animateStep();
            }

            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            stopCheat() {
                if (this.cheatInterval) {
                    clearInterval(this.cheatInterval);
                    this.cheatInterval = null;
                }
            }

            resetPuzzle() {
                this.puzzleArea.innerHTML = '<p style="text-align: center; margin-top: 180px; color: #999;">Upload an image and click "Generate Puzzle" to start!</p>';
                this.originalImageContainer.style.display = 'none';
                this.image = null;
                this.pieces = [];
                this.placedPieces = 0;
                this.totalPieces = 0;
                this.imageInput.value = '';
                this.generateBtn.disabled = true;
                this.resetBtn.disabled = true;
                this.fullscreenBtn.disabled = true;
                this.cheatBtn.disabled = true;
                
                // Stop any active cheat
                this.stopCheat();
                
                // Reset sliders to 4x4
                this.rowsSlider.value = 4;
                this.colsSlider.value = 4;
                this.rowsValue.textContent = '4';
                this.colsValue.textContent = '4';
                
                this.updateStats();
            }
        }

        // Initialize the puzzle when the page loads
        const puzzle = new JigsawPuzzle();
    </script>
</body>
</html>

