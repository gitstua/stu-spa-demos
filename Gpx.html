<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX Viewer with Elevation Graph</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; text-align: center; }
        #map { height: 60vh; width: 100vw; }
        #fileInput { margin: 10px; }
        #chart-container { width: 80vw; height: 30vh; margin: auto; }
        .layer-select { 
            margin: 10px;
            padding: 5px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h2>GPX Viewer with Elevation Graph</h2>
    <div class="file-upload">
        <input type="file" id="fileInput" multiple accept=".gpx,.kml" />
        <label for="fileInput">Upload GPX or KML files</label>
    </div>
    <select id="layerSelect" class="layer-select">
        <option value="osm">OpenStreetMap</option>
        <option value="satellite">Satellite</option>
        <option value="terrain">Terrain</option>
        <option value="topo">Topographic</option>
    </select>
    <div id="map"></div>
    <div id="chart-container">
        <canvas id="elevationChart"></canvas>
    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        const map = L.map('map').setView([-33.8688, 151.2093], 10);

        // Define different map layers
        const mapLayers = {
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors'
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '&copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            }),
            terrain: L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.png', {
                attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }),
            topo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenTopoMap contributors'
            })
        };

        // Set default layer
        let currentLayer = mapLayers.osm.addTo(map);

        // Add layer selection handler
        document.getElementById('layerSelect').addEventListener('change', function(e) {
            // Remove current layer
            map.removeLayer(currentLayer);
            // Add selected layer
            currentLayer = mapLayers[e.target.value].addTo(map);
        });

        // Add a feature group to track our layers
        const trackGroup = L.featureGroup().addTo(map);

        const elevationChartCtx = document.getElementById('elevationChart').getContext('2d');
        let elevationChart = new Chart(elevationChartCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                plugins: { legend: { display: true } },
                scales: {
                    x: { title: { display: true, text: "Distance (km)" } },
                    y: { title: { display: true, text: "Elevation (m)" } }
                }
            }
        });

        // Add the event listener
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);

        function handleFileSelect(event) {
            const files = event.target.files;
            if (!files.length) return;

            // Clear previous data
            elevationChart.data.datasets = [];
            elevationChart.update();
            
            // Clear all tracks and markers
            trackGroup.clearLayers();

            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    
                    if (file.name.toLowerCase().endsWith('.gpx')) {
                        parseGPXFile(content, file.name, index);
                    } else if (file.name.toLowerCase().endsWith('.kml')) {
                        parseKMLFile(content, file.name, index);
                    }
                };
                reader.readAsText(file);
            });
        }

        function parseKMLFile(content, fileName, index) {
            const parser = new DOMParser();
            const kml = parser.parseFromString(content, "text/xml");
            
            const coordinates = [];
            const placemarks = kml.getElementsByTagName('Placemark');
            
            for (const placemark of placemarks) {
                // Try different coordinate containers
                const coordContainers = [
                    ...placemark.getElementsByTagName('LineString'),
                    ...placemark.getElementsByTagName('Track'),
                    ...placemark.getElementsByTagName('gx:Track'),
                    ...placemark.getElementsByTagName('Point')
                ];

                for (const container of coordContainers) {
                    // Try standard coordinates tag
                    let coords = container.getElementsByTagName('coordinates')[0];
                    
                    if (!coords) {
                        // Try gx:coord tags (used in some KML files)
                        const gxCoords = container.getElementsByTagName('gx:coord');
                        if (gxCoords.length > 0) {
                            for (const gxCoord of gxCoords) {
                                const coordStr = gxCoord.textContent.trim();
                                const [lon, lat, ele] = coordStr.split(' ').map(parseFloat);
                                if (lat && lon) {
                                    coordinates.push([lat, lon, ele || 0]);
                                }
                            }
                            continue;
                        }
                    }

                    if (coords) {
                        const coordStr = coords.textContent.trim();
                        // Split on whitespace and filter out empty strings
                        const coordArray = coordStr.split(/\s+/).filter(coord => coord.trim());
                        
                        coordArray.forEach(coord => {
                            const [lon, lat, ele] = coord.split(',').map(parseFloat);
                            if (lat && lon) {
                                coordinates.push([lat, lon, ele || 0]);
                            }
                        });
                    }
                }
            }

            if (coordinates.length > 0) {
                displayTrack(coordinates, fileName, index);
            } else {
                // Try to find coordinates in a different format
                const when = kml.getElementsByTagName('when');
                const coord = kml.getElementsByTagName('gx:coord');
                
                if (when.length > 0 && coord.length > 0) {
                    for (let i = 0; i < coord.length; i++) {
                        const coordStr = coord[i].textContent.trim();
                        const [lon, lat, ele] = coordStr.split(' ').map(parseFloat);
                        if (lat && lon) {
                            coordinates.push([lat, lon, ele || 0]);
                        }
                    }
                }
                
                if (coordinates.length > 0) {
                    displayTrack(coordinates, fileName, index);
                } else {
                    alert(`No valid coordinates found in KML file: ${fileName}`);
                }
            }
        }

        function parseGPXFile(content, fileName, index) {
            const parser = new DOMParser();
            const xml = parser.parseFromString(content, "application/xml");
            const track = xml.querySelectorAll("trkpt");

            if (track.length === 0) {
                alert(`No track points in file: ${fileName}`);
                return;
            }

            let coordinates = [];
            track.forEach((pt) => {
                const lat = parseFloat(pt.getAttribute("lat"));
                const lon = parseFloat(pt.getAttribute("lon"));
                const eleTag = pt.querySelector("ele");
                const ele = eleTag ? parseFloat(eleTag.textContent) : 0;
                coordinates.push([lat, lon, ele]);
            });

            displayTrack(coordinates, fileName, index);
        }

        function displayTrack(coordinates, fileName, index) {
            let latlngs = [];
            let elevations = [];
            let distances = [];
            let totalDistance = 0;

            coordinates.forEach((coord, i) => {
                const [lat, lon, ele] = coord;
                latlngs.push([lat, lon]);
                elevations.push(ele);

                if (i > 0) {
                    const prev = coordinates[i - 1];
                    const d = getDistanceFromLatLon(prev[0], prev[1], lat, lon);
                    totalDistance += d;
                }
                distances.push(totalDistance.toFixed(2));
            });

            // Add track to map and center on first point
            const polyline = L.polyline(latlngs, { color: getColor(index) });
            trackGroup.addLayer(polyline);
            
            if (latlngs.length > 0) {
                if (index === 0) {
                    // Center on first point of first track
                    map.setView(latlngs[0], 13);
                }
                // Add marker for start point
                const marker = L.marker(latlngs[0], {
                    title: `Start - ${fileName}`,
                    icon: L.divIcon({
                        className: 'start-marker',
                        html: '⭐',
                        iconSize: [20, 20]
                    })
                });
                trackGroup.addLayer(marker);
            }

            // Fit bounds to show all tracks
            if (trackGroup.getLayers().length > 0) {
                map.fitBounds(trackGroup.getBounds());
            }

            // Add elevation data
            elevationChart.data.datasets.push({
                label: fileName,
                data: elevations,
                borderColor: getColor(index),
                fill: false
            });
            elevationChart.data.labels = distances;
            elevationChart.update();
        }

        function getDistanceFromLatLon(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the Earth in km
            const dLat = (lat2 - lat1) * (Math.PI / 180);
            const dLon = (lon2 - lon1) * (Math.PI / 180);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function getColor(index) {
            const colors = ['blue', 'red', 'green', 'purple', 'orange', 'brown', 'cyan', 'magenta'];
            return colors[index % colors.length];
        }
    </script>
</body>
</html>